# Deploying  Kubenews Web App

## 1 - Web Appplication
1 - Fork and clone the repo

2 - build and push the docker imagem

```bash

# v1
docker build -t scostadoc/aula-kube-news:v1 --push .

# latest
docker build -t scostadoc/aula-kube-news:latest --push .

```

## 2 - Cluster Kubernetes using Kind

Create yaml file called "kind-config.yaml":

```yaml

kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
networking:
  disableDefaultCNI: true # I disabled this one, we should install calico
nodes:
  - role: control-plane
    image: kindest/node:v1.34.3
    extraPortMappings:
     - containerPort: 30000
       hostPort: 30000
       listenAddress: "0.0.0.0"
       protocol: TCP
  - role: control-plane
    image: kindest/node:v1.34.3
  - role: control-plane
    image: kindest/node:v1.34.3
  - role: worker
    image: kindest/node:v1.34.3
  - role: worker
    image: kindest/node:v1.34.3
  - role: worker
    image: kindest/node:v1.34.3
  - role: worker
    image: kindest/node:v1.34.3



```


Run the command to create the kubernetes cluster

```bash

kind create cluster --name mycluster --config kind-config.yaml

kubectl get nodes

```


## 3 - Setup the database

Create a folder called "k8s" to hold all the files related with our deployment. Creatge a new file called "deploy.yaml". Let's work in the manifest file now.

deploy.yaml:

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgresql
spec:
  selector:
    matchLabels:
      app: postgresql
  template:
    metadata:
      labels:
        app: postgresql
    spec:
      containers:
      - name: postgresql
        image: postgres:15.0
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_PASSWORD
          value: "Pg#123"
        - name: POSTGRES_USER
          value: "kubenews"
        - name: POSTGRES_DB
          value: "kubenews"

---

apiVersion: v1
kind: Service
metadata:
  name: postgresql
spec:
  selector:
    app: postgresql
  ports:
    - port: 5432
      targetPort: 5432

```

Now apply the configuration 

```bash

kubectl apply -f k8s/deploy.yaml

kubectl get po


```

The database service is a  ***ClusterIp***, it means it won't be accessible outside our internal environment. 

If want to test our database connectivity, we should use the porforward command.

```bash

kubectl get svc

kubectl port-forward service/postgresql 5432:5432

```

You can use the DBeaver to test it

## 4 Deploying the web application

It is a good practise to keep all service together in the deploy.yaml file:

***deploy.yaml***:


```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgresql
spec:
  selector:
    matchLabels:
      app: postgresql
  template:
    metadata:
      labels:
        app: postgresql
    spec:
      containers:
      - name: postgresql
        image: postgres:15.0
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_PASSWORD
          value: "Pg#123"
        - name: POSTGRES_USER
          value: "kubenews"
        - name: POSTGRES_DB
          value: "kubenews"

---

apiVersion: v1
kind: Service
metadata:
  name: postgresql
spec:
  selector:
    app: postgresql
  ports:
    - port: 5432
      targetPort: 5432
---


apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubenews
spec:
  replicas: 10
  selector:
    matchLabels:
      app: kubenews
  template:
    metadata:
      labels:
        app: kubenews
    spec:
      containers:
      - name: kubenews
        image: fabricioveronez/aula-kube-news:v1
        ports:
        - containerPort: 8080
        env:
        - name: DB_PASSWORD
          value: "Pg#123"
        - name: POSTGRES_USER
          value: "kubenews"
        - name: DB_DATABASE
          value: "kubenews"
        - name: DB_HOST
          value: postgresql
---

apiVersion: v1
kind: Service
metadata:
  name: kubenews
spec:
  selector:
    app: kubenews
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30000
  type: NodePort
```


Now you can access the appliation using the url

```

http://localhost:30000

```


## 5 Deploying on the cloud 

As you don't have access to the machines or pods on the cloud, we have to change the type of the service from **NodePort** to **LoadBalancer**:

```yaml

apiVersion: v1
kind: Service
metadata:
  name: kubenews
spec:
  selector:
    app: kubenews
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30000
  type: LoadBalancer
```


Checking the public IP generated by the digital Ocean:

```bash

kubectl get svc

```

## Challenge 

Change the configuration to use secret or configMap.